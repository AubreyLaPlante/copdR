---
title: "mat2COPD"
author: "Aubrey LaPlante"
date: "2024-02-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#library(copdr)
### mat2COPD using COPDR ###
# This code is meant to import probability distribution functions (PDFs), i.e. Gaussian curves,
# and combine them in a modicum of ways for the user, based on several filters to take out the noisy PDFs 
# or PDFs with high uncertainties (i.e. large standard deviations, high coefficient of variation, etc).
# These PDFs are produced from LaDiCaoz, a Matlab program that allows you to 'backslip' offset on a fault
# from digital elevation models (DEMs) or digital surface models (DSMs)


library(devtools)
load_all()
```


## 1. Load in data ###
```{r}
## USER DEFINED INPUTS ##

#create a reference vector of offset names from file names in a folder
#after running this you will be prompted to enter the folder name
#this does NOT need quotations around it
backslip_names <- list.mat()

folder_name = "example_mat"

#Import metadata
#See example table "example.csv" for how your reference table should be formatted
csv_name = "example.csv"

#########################




## DO NOT EDIT ##
#create a list containing three dataframes, including 1. lateral, 2. vertical, 3. total offset
backslip_data <- matrix.mat(folder_name,backslip_names)

#load in your reference CSV. See example table "example.csv" for how your table should be formatted
backslip_csv <- readr::read_csv(csv_name, show_col_types = FALSE)

##################
```


## 2. Data pre-processing

2.1. Visualize raw data
```{r}
## DO NOT EDIT ##

#prep data for plotting
raw_lat_data <- simplify4plot(backslip_data[[1]], "lateral")
raw_vert_data <- simplify4plot(backslip_data[[2]], "vertical")
raw_total_data <- simplify4plot(backslip_data[[3]], "total")

# plot raw data
plotMat(raw_lat_data,"lateral")
plotMat(raw_vert_data,"vertical")
plotMat(raw_total_data,"total")

##################

```

2.2 Clip raw data and plot
```{r}

## USER-DEFINED LIMITS ##
lat_limits <- list(
     lat_x_min = -5,
     lat_x_max = 0,
     lat_y_min = 0,
     lat_y_max = 1
)

vert_limits <- list(
     vert_x_min = -1,
     vert_x_max = 0,
     vert_y_min = 0,
     vert_y_max = 1
)

total_limits <- list(
     total_x_min = 0,
     total_x_max = 5,
     total_y_min = 0,
     total_y_max = 1
)  

#######################



## DO NOT EDIT ##

#clip x limits of data
backslip_data_clip <- list(
     backslip_lat = data.clip(backslip_data[[1]],"lateral",lat_limits[[1]],lat_limits[[2]]),
     backslip_vert = data.clip(backslip_data[[2]],"vertical",vert_limits[[1]],vert_limits[[2]]),
     backslip_tot = data.clip(backslip_data[[3]],"total",total_limits[[1]],total_limits[[2]])
)

# plot clipped data
plotMat(simplify4plot(backslip_data_clip[[1]], "lateral"),"lateral",
        lat_limits[[1]],lat_limits[[2]],lat_limits[[3]],lat_limits[[4]])
plotMat(simplify4plot(backslip_data_clip[[2]], "vertical"),"vertical",
        vert_limits[[1]],vert_limits[[2]], vert_limits[[3]],vert_limits[[4]])
plotMat(simplify4plot(backslip_data_clip[[3]], "total"),"total",
        total_limits[[1]],total_limits[[2]],total_limits[[3]],total_limits[[4]])


##################
```

2.3 Confidence Scaling
```{r}
## USER DEFINED INPUT ##

#column of csv table corresponding to confidence values
confidence_column = 9
N_observations = 205

########################




## DO NOT EDIT ##

#scale the data by confidence values and put in a new list
backslip_data_Cscale <- backslip_data
for(i in 1:3){
     backslip_data_Cscale[[i]] <- conf.scale(backslip_data[[i]],backslip_csv, confidence_column, N_observations)
}


# plot confidence-scaled data
plotMat(simplify4plot(backslip_data_Cscale[[1]], "lateral"),"lateral",
        lat_limits[[1]],lat_limits[[2]],lat_limits[[3]],lat_limits[[4]])
plotMat(simplify4plot(backslip_data_Cscale[[2]], "vertical"),"vertical",
        vert_limits[[1]],vert_limits[[2]], vert_limits[[3]],vert_limits[[4]])
plotMat(simplify4plot(backslip_data_Cscale[[3]], "total"),"total",
        total_limits[[1]],total_limits[[2]],total_limits[[3]],total_limits[[4]])
##################
```

2.4 Coefficient of variation (COV) calculation

```{r}
#the master reference CSV "backslip_csv" should have 4-6 columns for displacement statistics
# 1. lateral mean, 2. lateral standard deviation, 3. vertical mean, 4. vertical standard deviation,
# 5. total mean, 6. total standard devation
# for all offset sites

#inputs will need to be the columns of offset data

#the following code calculates the coefficient of variation, 
#which is the standard deviation divided by the mean
#I used lateral in my example because in the example data,
#vertical displacement is poorly resolved and small magnitude

## USER DEFINED INPUT ##
# these are the column numbers corresponding to this data in the reference csv
lat_mean = 13
lat_stdev = 14
vert_mean = 15
vert_stdev = 16
total_mean = 17
total_stdev = 18

########################
     


## DO NOT EDIT ##

backslip_csv <- calc.cov(backslip_csv,"lateral", lat_mean, lat_stdev)
backslip_csv <- calc.cov(backslip_csv,"vertical",vert_mean, vert_stdev)
backslip_csv <- calc.cov(backslip_csv,"total",total_mean, total_stdev)
########################
```


## 3. Filters ##

# these filters will work to clip master data matrices to include only file names
# that meet a set of criteria
# users will define these criteria and the code will filter through the CSV and data matrices to remove
# PDFs that do not fit these criteria

# Each filter will essentially clip the data and produce an output of PDFs that can be plotted, which can then be fed into any of the other filters

3.1 COV filters
```{r}
#these are the COV values you want to filter for
COV_filter_vals <- seq(.10,.30, by=0.05) 



## DO NOT EDIT ##
# this creates reference data files for the offset_IDs and the corresponding COV values
lat_cov <- filter.covREF(backslip_csv,1,"lateral",COV_filter_vals)
vert_cov <- filter.covREF(backslip_csv,1,"vertical",COV_filter_vals)
total_cov <- filter.covREF(backslip_csv,1,"total",COV_filter_vals)

### this filters the input datatable 'backslip_data' by the filtered COV reference files created using filter.covREF
lat_cov2 <- filter.covDAT(backslip_csv,1,"lateral",COV_filter_vals,lat_cov,backslip_data_Cscale)
vert_cov2 <- filter.covDAT(backslip_csv,1,"vertical",COV_filter_vals,vert_cov,backslip_data_Cscale)
total_cov2 <- filter.covDAT(backslip_csv,1,"total",COV_filter_vals,total_cov,backslip_data_Cscale)
########################

# plot confidence-scaled data
plotMat(simplify4plot(lat_cov2[[5]], "lateral"),"lateral",
        lat_limits[[1]],lat_limits[[2]],lat_limits[[3]],lat_limits[[4]])
plotMat(simplify4plot(vert_cov2[[5]], "vertical"),"vertical",
        vert_limits[[1]],vert_limits[[2]], vert_limits[[3]],vert_limits[[4]])
plotMat(simplify4plot(total_cov2[[5]], "total"),"total",
        total_limits[[1]],total_limits[[2]],total_limits[[3]],total_limits[[4]])
##################
```

3.2 Standard deviation filters

```{r}
SD_filter_vals <- seq(.10,.30, by=0.05) 
```


3.3 Age filters

```{r}
AGE_filter_vals <- c("Qf7", "Qf6a","Qf6b")
```

3.4 Confidence filters

```{r}
Conf_filter_vals <- seq(1,3, by=0.5)
```


3.5 Landform filters

```{r}
MORPH_filter_vals <- c("bar", "swale","fan")
```


## 4. Optimization ##

```{r}
## input functions (onePeak, twoPeak, threePeak, fourPeak, etc) will NOT be user facing

# optimCOPD function WILL be user facing

#input parameters will need to be a user-defined table/csv
```


## 5. Final Plots ##

```{r}
## combining filtered data with optimization curves
## analyzing trends and producing final graphs
```



